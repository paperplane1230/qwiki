# Notes on TCP

## 保活定时器（keepalive）

如果一个给定的连接在两小时内没有任何动作，服务器就向客户发送一个探查报文段。客户端必须处于以下 4 个状态之一：

* 主机正常运行，且从服务器可达。客户 TCP 响应正常，服务器两小时后将保活定时器复位。如果期间有通信量通过此连接，则定时器在交换数据后的未来两小时再复位
* 客户端主机已崩溃，并且关闭 或者 正在重启。客户 TCP 无响应，75 秒后超时。服务器共发送 10 个这样的探查，每个间隔 75 秒。如果都没有响应，认为客户主机已关闭并终止连接
* 客户主机崩溃并已经重启。响应是一个复位，使服务器终止该连接
* 客户主机正常，但从服务器不可达。和状态 2 相同，TCP 不能区分该状态和状态 2 的区别

### 优点

* 通常比显式编写应用层探测报文容易
* 比应用层探测报文占用更少带宽（keepalive 探测报文和应答不包含任何数据）
* 如果连接不空闲，不会发送探测报文

### 缺点

* 可能会由于一个临时性的网络中断而断开连接
* 发送探测报文的间隔（2 小时）一般不可以根据应用进行配置

## RPC

### 论文

* RFC 707
* Implementing Remote Procedure Calls
* RFC 1831
* RFC 1832(XDR)
* RFC 1833(RPCBIND)

### 争议

* [有关评论](http://www.kohala.com/start/papers.others/rpc.comments.txt)

### 服务器捆绑

1. 系统进入多用户模式时，端口映射器启动（portmap 或 rpcbind）
2. 服务器启动时，main 调用 svc_create。其确定本主机所支持的网络协议，为每个协议创建一个传输端点，给 TCP 和 UDP 端点各捆绑一个临时端口。该函数和本地端口映射器联系，注册临时端口号和调用程序的 RPC 程序号和版本号。客户在创建句柄时选择使用哪个协议（clnt_create）
3. 客户启动并调用 clnt_create。向服务器主机的端口映射器发送一个 RPC 请求，询问关于所指定的程序、版本和协议的信息。成功的话，作为答复的服务器端口号就保存到客户句柄，供将来使用该句柄的所有 RPC 调用参考

32 位的程序号划分成组：

* 0x00000000 - 0x1fffffff: Sun 定义
* 0x20000000 - 0x3fffffff: 用户定义
* 0x40000000 - 0x5fffffff: 临时
* 0x60000000 - 0xffffffff: 保留

## 作为守护进程启动的步骤

* 调用 `fork` 转到后台运行
* 调用 `setsid` 建立一个新的 POSIX 会话并成为会话头进程
* 再次 fork 避免无意中获得新的控制终端
* 改变工作目录和文件创建模式掩码
* 关闭非必要的描述符

作为守护进程编写的程序可能是从某个系统启动命令脚本执行的，**不应该**假设任何出错消息都能写到某个终端。所有出错消息都应该使用 `syslog` 登记

## 排队的数据量

* 既想查看数据，又想数据仍然留在接受队列中供本进程其他部分稍后读取，可以使用 MSG_PEEK 标志。就 UDP 而言，假设其接收队列已有一个数据报，指定 MSG_PEEK 调用一次 recvfrom，稍后不指定该标志再调用一次，即使另有数据报在这两次调用之间加入套接字接收队列，两次调用返回值也完全相同
