# Notes on MySQL

## Explain

### 限制

* 不会告诉你触发器、存储过程或 UDF 会如何影响查询
* 不支持存储过程，尽管可以手动抽取查询并单独对其进行 EXPLAIN 操作
* 不会告诉你你 MySQL 在查询执行中所做的特定优化
* 不会显示关于查询的执行计划的所有信息
* 不区分具有相同名字的事物。例如，对内存排序和文件排序都使用 "filesort", 并且对于磁盘上和内存上的临时表都显示 "Using temporary"
* 可能会误导。例如，会对一个有着很小 LIMIT 的查询显示全索引扫描

## 选择数据类型的原则

* 更小的通常更好
* 简单就好. 使用 MySQL 内建的类型(date, time, datatime)而不是字符串来存储日期和时间; 用整型存储 IP 地址
* 尽量避免 NULL. 对 MySQL 来说更难优化. 可为 NULL 的列会使用更多的存储空间. 如果计划在列上建索引, 应该尽量避免设计成可为 NULL

TIMESTAMP 只使用 DATETIME 一半的存储空间, 会根据时区变化, 具有特殊的自动更新能力. 允许的时间范围要小得多

### 实数类型

可以使用 DECIMAL 存储比 BIGINT还大的整数. MySQL 既支持精确类型, 也支持不精确类型. 
浮点类型在存储同样范围的值时, 通常比 DECIMAL 使用更少的空间. 
因为需要额外的空间和计算开销, 应该尽量只在对小数进行精确计算时才使用 DECIMAL

### VARCHAR

下面这些情况使用 VARCHAR 是合适的:

* 字符串列的最大长度比平均长度大很多
* 列的更新很少, 碎片不是问题
* 使用了像 UTF-8 这样复杂的字符集, 每个字符都是用不同的字节数进行存储

在 5.0 或更高版本, MySQL 在存储和检索时会保留末尾空格; InnoDB 更灵活, 可以把过长的 VARCHAR 存储为 BLOB

### CHAR

MYSQL 会删除所有的末尾空格

* 适合存储很短的字符串, 或者所有值都接近同一个长度
* 适合经常变更的数据, 不容易产生碎片
* 对于非常短的列, 在存储空间上更有效率

当需要存储二进制数据时, 并希望使用字节码而不是字符进行比较, BINARY 和 VARBINARY 非常有用. 二进制的有事不仅体现在大小写敏感上, 其比较也比字符比较简单得多, 也就更快

### DATETIME

能保存大范围的值, 从 1001 年到 9999 年, 精度为秒, 与时区无关. 使用 8 个字节的存储空间

### TIMESTAMP

和 UNIX 时间戳相同. 只使用 4 个字节的存储空间. 显示的值也依赖于时区

TIMESTAMP 空间效率比 DATETIME 高

