# Notes on MySQL

## 隔离级别

* READ UNCOMMITTED (未提交读): 事务可以读取未提交的数据, 脏读 (Dirty Read)
* READ COMMITTED (提交读): 不可重复读 (nonrepeatable read), 两次执行同样的查询, 可能会得到不一样的结果
* REPEATABLE READ (可重复读): 保证同一个事务中多次读取同样记录的结果是一致的. 无法解决幻读 (Phantom Read): 某个事务在读取某个范围内的记录时, 另外一个事务又在该范围内**插入新的记录**, 之前的事务再次读取该范围内的记录时, 产生幻行 (Phantom Row). MVCC 解决幻读
* SERIALIZABLE (可串行化): 强制事务串行执行, 会在读取的每一行数据上都加锁
## Explain

### 限制

* 不会告诉你触发器、存储过程或 UDF 会如何影响查询
* 不支持存储过程，尽管可以手动抽取查询并单独对其进行 EXPLAIN 操作
* 不会告诉你你 MySQL 在查询执行中所做的特定优化
* 不会显示关于查询的执行计划的所有信息
* 不区分具有相同名字的事物。例如，对内存排序和文件排序都使用 "filesort", 并且对于磁盘上和内存上的临时表都显示 "Using temporary"
* 可能会误导。例如，会对一个有着很小 LIMIT 的查询显示全索引扫描

## 选择数据类型的原则

* 更小的通常更好
* 简单就好. 使用 MySQL 内建的类型(date, time, datatime)而不是字符串来存储日期和时间; 用整型存储 IP 地址
* 尽量避免 NULL. 对 MySQL 来说更难优化. 可为 NULL 的列会使用更多的存储空间. 如果计划在列上建索引, 应该尽量避免设计成可为 NULL

TIMESTAMP 只使用 DATETIME 一半的存储空间, 会根据时区变化, 具有特殊的自动更新能力. 允许的时间范围要小得多

### 实数类型

可以使用 DECIMAL 存储比 BIGINT还大的整数. MySQL 既支持精确类型, 也支持不精确类型. 
浮点类型在存储同样范围的值时, 通常比 DECIMAL 使用更少的空间. 
因为需要额外的空间和计算开销, 应该尽量只在对小数进行精确计算时才使用 DECIMAL

### VARCHAR

下面这些情况使用 VARCHAR 是合适的:

* 字符串列的最大长度比平均长度大很多
* 列的更新很少, 碎片不是问题
* 使用了像 UTF-8 这样复杂的字符集, 每个字符都是用不同的字节数进行存储

在 5.0 或更高版本, MySQL 在存储和检索时会保留末尾空格; InnoDB 更灵活, 可以把过长的 VARCHAR 存储为 BLOB

### CHAR

MYSQL 会删除所有的末尾空格

* 适合存储很短的字符串, 或者所有值都接近同一个长度
* 适合经常变更的数据, 不容易产生碎片
* 对于非常短的列, 在存储空间上更有效率

当需要存储二进制数据时, 并希望使用字节码而不是字符进行比较, BINARY 和 VARBINARY 非常有用. 二进制的有事不仅体现在大小写敏感上, 其比较也比字符比较简单得多, 也就更快

### DATETIME

能保存大范围的值, 从 1001 年到 9999 年, 精度为秒, 与时区无关. 使用 8 个字节的存储空间

### TIMESTAMP

和 UNIX 时间戳相同. 只使用 4 个字节的存储空间. 显示的值也依赖于时区

TIMESTAMP 空间效率比 DATETIME 高

### BIT

可以使用 BIT 列在一列中存储一个或多个 true / false. BIT(1) 定义一个包含单个位的字段, BIT(2) 存储 2 个位. 最大长度是 64 个位

BIT 的行为令人费解, 应该谨慎使用. 对于大部分应用, 最好避免使用. 如果想在一个 bit 的存储空间存储一个 true / false 值, 可以创建一个空的 CHAR(0) 列, 可以保存空值(NULL) 或者长度为 0 的字符串(空字符串)

### SET

如果需要保存很多 true / false, 可以考虑合并这些列到一个 SET 数据类型, MySQL 用一系列打包的位的集合表示. 有效利用存储空间. 一般来说, 无法在 SET 列通过索引查找

## schema 设计中的陷阱

* 太多的列. 存储引擎 API 工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据, 在服务器层将缓冲内容编码成各个列. MyISAM 变长行结构和 InnoDB 行结构总需要转换
* 太多关联. 如果希望查询执行得快速且并发性好, 单个查询最好在 12 个表以内做关联
* 全能的枚举
* 变相的枚举. 枚举列允许在列中存储一组定义值中的单个值, 集合列则允许在列中存储一组定义值中的一个或多个值
* 非此发明(Not Invent Here)的 NULL. 当确实需要表示未知值时, 在某些场景, NULL 可能会比某个神奇常数更好

### 范式化优点

* 更新操作比反范式化快
* 很少或者没有重复数据, 只需要修改更少的数据
* 表通常更小, 可以更好地放在内存里, 执行操作会更快
* 检索列表数据时更少需要 DISTINCT 或者 GROUP BY

### 范式化缺点

通常需要关联. 不但代价昂贵, 也可能使一些索引策略无效

## 物化视图

预先计算并存储在磁盘上的表. MySQL 不原生支持物化视图. 开源工具: Flexviews

## 计数器表

可以将计数器保存在多行中, 每次随机选择一行进行更新. 统计时使用聚合查询
